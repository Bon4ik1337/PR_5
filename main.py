# -*- coding: utf-8 -*-
"""python_practice_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-6p9ru1FGi4XgToybLr6krxv6fleOrdO

# I. OOP

1. (7б). Створіть клас Animal, додайте docstring, три атрибути, один з яких має значення за замовчуванням та два методи на свій розсуд.
"""

class Animal:
    """
    Клас, що представляє тварину.

    Атрибути:
        name (str): Ім'я тварини.
        species (str): Вид тварини.
        sound (str): Звук, який вона видає (за замовчуванням "Гав").
    """

    def __init__(self, name, species, sound="Гав"):
        """
        Ініціалізація об'єкта Animal.

        Параметри:
            name (str): Ім'я тварини.
            species (str): Вид тварини.
            sound (str, опціонально): Звук, який вона видає (за замовчуванням "Гав").
        """
        self.name = name
        self.species = species
        self.sound = sound

    def make_sound(self):
        """Метод, що виводить звук, який видає тварина."""
        print(f"{self.name} видає звук: {self.sound}")

    def introduce(self):
        """Метод, що виводить інформацію про тварину."""
        print(f"Це {self.species} з іменем {self.name}.")

# Створення об'єкта класу Animal
my_cat = Animal(name="Рекс", species="Кіт", sound="Гав-гав")

# Виклик методів
my_cat.introduce()
my_cat.make_sound()

"""1.1. (5б). Створіть два обʼєкти цього класу. На одному обʼєкті отримайте значення його атрибуту, а на іншому викличте один з його методів."""

# Створення двох об'єктів класу Animal
dog1 = Animal(name="Шарик", species="Собака", sound="Гав")
cat1 = Animal(name="Мурка", species="Кіт", sound="Мяу")

# Отримання значення атрибуту для одного об'єкта
print(f"{dog1.name} є представником виду {dog1.species} і має звук {dog1.sound}.")

# Виклик методу для іншого об'єкта
cat1.introduce()

"""2. (9б). Створіть клас, де атрибути мають різні рівні доступу. Спробуйте отримати їхні значення та опишіть результати."""

class MyClass:
    def __init__(self):
        # Публічний атрибут
        self.public_attribute = "Це публічний атрибут"

        # Приватний атрибут (починається з подвійного підкреслення)
        self.__private_attribute = "Це приватний атрибут"

    def get_private_attribute(self):
        return self.__private_attribute


# Створення об'єкта класу
obj = MyClass()

# Отримання значення публічного атрибуту (має бути доступно)
print(obj.public_attribute)

# Отримання значення приватного атрибуту через метод
print(obj.get_private_attribute())

"""3. (8б). Як ви розумієте термін self? Для чого використовується метод __init __?

Термін self використовується в об'єктно-орієнтованому програмуванні і вказує на екземпляр класу, для якого викликається метод. self дозволяє об'єкту використовувати власні атрибути та методи. При визначенні методів класу в Python, перший параметр завжди є self.

Метод __init__ - це конструктор класу, і він викликається автоматично при створенні нового об'єкта класу. Його основна мета - ініціалізація атрибутів об'єкта. Все, що визначається в методі __init__, виконується при створенні нового екземпляра класу.

4. (8б). Створіть клас Фігура без атрибутів, з методом get_area для отримання площі фігури, що повертає 0 та __add __, який приймає self та other в якості аргументів, а повертає суму площин фігур self та other.
"""

class Figure:
    def get_area(self):
        # Цей метод повертає площу фігури, в даному випадку - завжди 0
        return 0

    def __add__(self, other):
        # Цей метод додає площу двох фігур
        if isinstance(other, Figure):
            # Перевірка, чи other є екземпляром класу Figure
            return self.get_area() + other.get_area()
        else:
            # Якщо other не є екземпляром класу Figure, видаємо виняток
            raise ValueError("Can only add two instances of Figure")

# Приклад використання:
figure1 = Figure()
figure2 = Figure()

area_sum = figure1 + figure2  # Сума площин двох фігур
print(area_sum)  # Виведе: 0

"""5. (11б). Створіть 2 дочірніх класи від Фігури: Трикутник та Коло, які мають атрибути, необхідні для розрахунку площин. Визначте метод get_area в кожному з них так, щоби вони розраховували площу в залежності від формули для кожного типу фігури. Створіть обʼєкт класу Трикутник та обʼєкт класу Коло. Виконайте операцію суми за допомогою оператора + між ними."""

import math

class Figure:
    def get_area(self):
        # Цей метод повертає площу фігури, в даному випадку - завжди 0
        return 0

    def __add__(self, other):
        # Цей метод додає площу двох фігур
        if isinstance(other, Figure):
            # Перевірка, чи other є екземпляром класу Figure
            return self.get_area() + other.get_area()
        else:
            # Якщо other не є екземпляром класу Figure, видаємо виняток
            raise ValueError("Can only add two instances of Figure")

class Triangle(Figure):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def get_area(self):
        # Площа трикутника: (1/2) * основа * висота
        return 0.5 * self.base * self.height

class Circle(Figure):
    def __init__(self, radius):
        self.radius = radius

    def get_area(self):
        # Площа кола: π * радіус^2
        return math.pi * self.radius**2

# Створення об'єктів
triangle = Triangle(base=5, height=8)
circle = Circle(radius=3)

# Розрахунок площі кожної фігури
print("Площа трикутника:", triangle.get_area())  # Виведе: 20.0
print("Площа кола:", circle.get_area())  # Виведе: 28.274333882308138

# Сума площ двох фігур
total_area = triangle + circle
print("Сумарна площа:", total_area)  # Виведе: 48.274333882308138

"""6. (7б). Продемонструйте різницю між isinstance та issubclass."""

class Animal:
    pass

class Dog(Animal):
    pass

obj = Dog()

print(isinstance(obj, Dog))     # True
print(isinstance(obj, Animal))  # True


class Animal:
    pass

class Dog(Animal):
    pass

print(issubclass(Dog, Animal))  # True
#Різниця в тому, що isinstance перевіряє екземпляр класу, тоді як issubclass перевіряє, чи один клас є підкласом іншого.

"""7. (16б). Створіть клас BankAccount з приватними атрибутами balance та account_number.
Реалізуйте методи поповнення та зняття коштів, забезпечивши належну інкапсуляцію. Підказка: використовуйте декоратори getter та setter.
"""

class BankAccount:
    def __init__(self, initial_balance=0, account_number=None):
        self._balance = initial_balance
        self._account_number = account_number

    @property
    def balance(self):
        """Getter для отримання значення балансу."""
        return self._balance

    @balance.setter
    def balance(self, new_balance):
        """Setter для встановлення нового значення балансу."""
        if new_balance >= 0:
            self._balance = new_balance
        else:
            print("Недопустима операція: баланс не може бути від'ємним.")

    def deposit(self, amount):
        """Метод для поповнення рахунку."""
        if amount > 0:
            self._balance += amount
            print(f"Поповнення на {amount} грн успішно. Новий баланс: {self._balance} грн.")
        else:
            print("Недопустима операція: сума поповнення повинна бути більше 0.")

    def withdraw(self, amount):
        """Метод для зняття коштів з рахунку."""
        if 0 < amount <= self._balance:
            self._balance -= amount
            print(f"Зняття {amount} грн успішно. Новий баланс: {self._balance} грн.")
        elif amount <= 0:
            print("Недопустима операція: сума зняття повинна бути більше 0.")
        else:
            print("Недостатньо коштів на рахунку.")

# Приклад використання
account1 = BankAccount(initial_balance=1000, account_number="123456789")
print(f"Початковий баланс рахунку {account1.balance} грн.")

account1.deposit(500)
account1.withdraw(200)
account1.balance = 1500  # Використання setter для встановлення нового балансу
print(f"Новий баланс рахунку: {account1.balance} грн.")

"""8. (16б). Створіть клас Library, який містить список об'єктів типу Book.
Реалізуйте методи для додавання книги, видалення книги та відображення списку книг.
"""

class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

class Library:
    def __init__(self):
        self.books = []

    def add_book(self, book):
        """Метод для додавання книги до бібліотеки."""
        self.books.append(book)
        print(f"Книга '{book.title}' додана до бібліотеки.")

    def remove_book(self, title):
        """Метод для видалення книги з бібліотеки за заголовком."""
        for book in self.books:
            if book.title == title:
                self.books.remove(book)
                print(f"Книга '{book.title}' видалена з бібліотеки.")
                break
        else:
            print(f"Книга з заголовком '{title}' не знайдена в бібліотеці.")

    def display_books(self):
        """Метод для відображення списку книг в бібліотеці."""
        if not self.books:
            print("Бібліотека порожня.")
        else:
            print("Список книг в бібліотеці:")
            for book in self.books:
                print(f"- '{book.title}' by {book.author}")

# Приклад використання
library = Library()

book1 = Book("Harry Potter and the Philosopher's Stone", "J.K. Rowling")
book2 = Book("To Kill a Mockingbird", "Harper Lee")
book3 = Book("1984", "George Orwell")

library.add_book(book1)
library.add_book(book2)
library.display_books()

library.remove_book("To Kill a Mockingbird")
library.display_books()

"""9. (13б). Створіть клас Person з атрибутами name та age.
Створіть ще один клас Employee з такими атрибутами, як department та salary.
Створіть клас Manager, який успадковує обидва класи Person та Employee. Продемонструйте використання множинної спадковості, створивши обʼєкт класу Manager та отримавши mro для цього класу.
"""

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Employee:
    def __init__(self, department, salary):
        self.department = department
        self.salary = salary

class Manager(Person, Employee):
    def __init__(self, name, age, department, salary, title):
        # Виклик конструкторів батьківських класів
        Person.__init__(self, name, age)
        Employee.__init__(self, department, salary)
        self.title = title

# Створення об'єкта класу Manager
manager = Manager(name="John Doe", age=35, department="HR", salary=50000, title="Senior Manager")

# Доступ до атрибутів з батьківських класів
print(f"Name: {manager.name}")
print(f"Age: {manager.age}")
print(f"Department: {manager.department}")
print(f"Salary: ${manager.salary}")
print(f"Title: {manager.title}")

# Виведення порядку методів розділених множинною спадковістю
print(f"MRO (Method Resolution Order): {Manager.mro()}")

"""# Вітаю! Ви велика(ий) молодець, що впоралась(вся). Похваліть себе та побалуйте чимось приємним. Я Вами пишаюся."""